# CURL


## 目录

* [简介](#简介)
* [常用参数详解](#常用参数详解)
* [CURL语法及选项](#CURL语法及选项)
* [About](#About)
* [License](#License)

## 简介

CURL 是常用的命令行工具,用来请求 Web 服务器,然后得到和提取数据,显示在"标准输出"（stdout）上面。
它的名字就是客户端（client）的 URL 工具的意思。它支持多种协议,功能非常强大,命令行参数多达几十种。
如果熟练的话,完全可以取代 Postman 这一类的图形界面工具。

我一向以为,CURL只是一个编程用的函数库。

最近才发现,这个命令本身,就是一个无比有用的网站开发工具,例如：

1. 查看网页源码
2. 自动跳转
3. 显示头信息
4. 显示通信过程
5. 发送表单信息
6. HTTP动词
7. 文件上传
8. Referer字段
9. UserAgent字段
10. cookie
11. 增加头信息
12. HTTP认证

## 常用参数详解

|参数|描述|
|:-----|:-----|
|AAAAAAAAAAAAA|AAAAAAAAAAAAA(为了显示效果)|
|-A/--user-agent|指定客户端的用户代理标头,即User-Agent。默认为`curl/[version]`|
| |`curl -v -A 'golang/1.0' http://127.0.0.1:8080/test`|
| |`curl -v -H 'User-Agent: golang/1.0' http://127.0.0.1:8080/test`同上|
|-b/--cookie|向服务器发送Cookie|
| |`curl -v -b user_name=admin http://127.0.0.1:8080/test`|
| |生成标头`Cookie: user_name=admin`|
| |`curl -v --cookie user_name=admin http://127.0.0.1:8080/test`同上|
|-c|将服务器设置的Cookie写入一个文件|
| |`curl -v -c cookies.txt http://127.0.0.1:8080/test`将Cookie写入[cookies.txt](#cookies文本内容)|
|-d/--data|发送POST请求的数据体|
| |`curl -v -d user_name=admin -d password=123456 http://127.0.0.1:8080/test`|
| |`curl -v -d 'user_name=admin&password=123456' http://127.0.0.1:8080/test`|
| |两种方式一样。使用`-d`参数以后,会自动将请求转为POST,|
| |并且会自动加上标头`Content-Type: application/x-www-form-urlencoded`|
| |`curl -v -d '@data.txt' http://127.0.0.1:8080/test`读取本地[data.txt](#data文本内容)文件的数据发送|
|--data-urlencode|等同于`-d`,发送POST请求的数据体,区别在于会自动将发送的数据进行URL编码|
| |`curl -v --data-urlencode 'user_name=ad min&password=123456' http://127.0.0.1:8080/test`|
| |发送的数据`user_name=ad min&password=123456`中有一个空格,需要URL编码|
|-e/--referer|用来设置标头`Referer`,表示请求的来源|
| |`curl -v -e 'http://127.0.0.1:8080/test' http://127.0.0.1:8080/test`|
| |`curl -v -H 'Referer: http://127.0.0.1:8080/test'  http://127.0.0.1:8080/test`同上|
|-F/--form|向服务器上传二进制文件|
| |`curl -F '[name]=@[localfilename]' -F [data] [URL]`|
| |`curl -v -F 'file=@logo.png' http://127.0.0.1:8080/test`|
| |使用-F参数以后,请求会自动加上标头`Content-Type: multipart/form-data`|
| |`curl -v -F 'file=@logo.png;type=image/png'  http://127.0.0.1:8080/test`指定类型|
| |上面命令指定MIME类型为`image/png`,否则会把MIME类型设为`application/octet-stream`|
| |`curl -v -F 'file=@logo.png;filename=test.png' http://127.0.0.1:8080/test`指定文件名|
|-G|构造URL的查询字符串|
| |`curl -v -G -d user_name=admin -d password=123456 http://127.0.0.1:8080/test`|
| |`curl -v -G -d 'user_name=admin&password=123456' http://127.0.0.1:8080/test`|
| |两种方式一样。使用`-G`参数后会发出一个GET请求|
| |`curl -v -G --data-urlencode 'user_name=ad min&password=123456' http://127.0.0.1:8080/test`如果数据需要URL编码,可以结合`--data-urlencode`参数|
|-H/--header|添加请求的标头|
| |`curl -v -H 'Accept-Language: en-US' -H 'Secret-Message: xyzzy' http://127.0.0.1:8080/test`|
| |`curl -v -d '{"user_name":"admin","password":"123456"}' -H 'content-type: application/json' http://127.0.0.1:8080/test`|
| |添加标头`Content-Type: application/json`,然后用`-d`参数发送JSON数据|
|-i|打印出服务器回应的HTTP标头|
| |`curl -i http://127.0.0.1:8080/test`|
| |上面命令收到服务器响应后,先输出服务器响应的标头,然后空一行,再输出网页的源码|
|-I/--head|向服务器发出HEAD请求,然会将服务器响应的HTTP标头打印出来|
| |`curl -v -I http://127.0.0.1:8080/test`|
| |`curl -v --head http://127.0.0.1:8080/test`|
|-k|指定跳过SSL检测|
| |`curl -v -k http://127.0.0.1:8080/test`|
|-L/--location|让HTTP请求跟随服务器重定向,默认不跟随重定向|
| |`curl -v -L http://127.0.0.1:8080/test`|
|--limit-rate|限制HTTP请求和回应的带宽,模拟慢网速的环境|
| |`curl -v --limit-rate 200k http://127.0.0.1:8080/test`将带宽限制在每秒200K字节|
|-o/--output|将服务器的回应保存成文件,等同于`wget`命令|
| |`curl -o [文件名] URL`|
| |`curl -v -o test.html http://127.0.0.1:8080/test`|
|-O/--remote-name|将服务器回应保存成文件,并将URL的最后部分当作文件名|
| |`curl -v -O http://127.0.0.1:8080/test.html`|
|-s/--silent|静默模式,不输出任何东西|
| |`curl -s http://127.0.0.1:8080/test`不会显示错误信息,不发生错误正常显示运行结果|
|-S|只输出错误信息|
| |`curl -S http://127.0.0.1:8080/test`|
|-u/--user|设置服务器认证的用户名和密码|
| |`curl -v -u 'admin"123456' http://127.0.0.1:8080/test`|
| |设置用户名为`admin`,密码为`123456`|
| |然后将其转为HTTP标头`Authorization: Basic YWRtaW4iMTIzNDU2OjEyMzQ1Ng==`|
| |`curl -v  http://admin:123456@127.0.0.1:8080/test`curl能够识别URL里面的用户名和密码|
| |`curl -v -u admin http://127.0.0.1:8080/test`只设置用户名,执行命令会提示用户输入密码|
|-v/--trace|输出通信的整个过程,用于调试|
| |`curl -v http://127.0.0.1:8080/test`|
| |如果你觉得上面的信息还不够,那么下面的命令可以查看更详细的通信过程,`--trace -`输出原始的二进制数据|
| |`curl --trace -  http://127.0.0.1:8080/test`|
| |`curl --trace-ascii output.txt http://127.0.0.1:8080/test` 打开[output.txt](#output文本内容)文件查看|
|-V/--version|显示版本信息|
| |`curl -V`|
|-x|指定HTTP请求的代理|
| |`curl -v -x http://10.64.144.3:8123 https://www.google.com`|
|-X|指定HTTP请求的方法|
| |`curl -v -X POST http://127.0.0.1:8080/test`发出POST请求|
| |`curl -v -X DELETE http://127.0.0.1:8080/test` 发出DELETE请求|
|||
|||
|||
|||
|||
|||

### cookies文本内容

```
# Netscape HTTP Cookie File
# https://curl.haxx.se/docs/http-cookies.html
# This file was generated by libcurl! Edit at your own risk.

127.0.0.1	FALSE	/	FALSE	61572939117	user_id	10001
```

#### data文本内容

```
user_name=admin&password=123456
```

### output文本内容

```
== Info:   Trying 127.0.0.1...
== Info: TCP_NODELAY set
== Info: Connected to 127.0.0.1 (127.0.0.1) port 8080 (#0)
=> Send header, 82 bytes (0x52)
0000: GET /test HTTP/1.1
0014: Host: 127.0.0.1:8080
002a: User-Agent: curl/7.54.0
0043: Accept: */*
0050:
<= Recv header, 17 bytes (0x11)
0000: HTTP/1.1 200 OK
<= Recv header, 47 bytes (0x2f)
0000: Content-Type: application/json; charset=utf-8
<= Recv header, 37 bytes (0x25)
0000: Date: Wed, 06 Nov 2019 06:19:24 GMT
<= Recv header, 20 bytes (0x14)
0000: Content-Length: 74
<= Recv header, 2 bytes (0x2)
0000:
<= Recv data, 74 bytes (0x4a)
0000: {"query_form":{},"form":{},"post_form":{},"multipart_form":null,
0040: "body":""}
== Info: Connection #0 to host 127.0.0.1 left intact
```

## CURL语法及选项

CURL（7.29.0）所支持的选项（options）参数如下:

```
在以下选项中，(H) 表示仅适用 HTTP/HTTPS ，(F) 表示仅适用于 FTP
    --anyauth       选择 "any" 认证方法 (H)
-a, --append        添加要上传的文件 (F/SFTP)
    --basic         使用HTTP基础认证（Basic Authentication）(H)
    --cacert FILE   CA 证书，用于每次请求认证 (SSL)
    --capath DIR    CA 证书目录 (SSL)
-E, --cert CERT[:PASSWD] 客户端证书文件及密码 (SSL)
    --cert-type TYPE 证书文件类型 (DER/PEM/ENG) (SSL)
    --ciphers LIST  SSL 秘钥 (SSL)
    --compressed    请求压缩 (使用 deflate 或 gzip)
-K, --config FILE   指定配置文件
    --connect-timeout SECONDS  连接超时设置
-C, --continue-at OFFSET  断点续转
-b, --cookie STRING/FILE  Cookies字符串或读取Cookies的文件位置 (H)
-c, --cookie-jar FILE  操作结束后，要写入 Cookies 的文件位置 (H)
    --create-dirs   创建必要的本地目录层次结构
    --crlf          在上传时将 LF 转写为 CRLF
    --crlfile FILE  从指定的文件获得PEM格式CRL列表
-d, --data DATA     HTTP POST 数据 (H)
    --data-ascii DATA  ASCII 编码 HTTP POST 数据 (H)
    --data-binary DATA  binary 编码 HTTP POST 数据 (H)
    --data-urlencode DATA  url 编码 HTTP POST 数据 (H)
    --delegation STRING GSS-API 委托权限
    --digest        使用数字身份验证 (H)
    --disable-eprt  禁止使用 EPRT 或 LPRT (F)
    --disable-epsv  禁止使用 EPSV (F)
-D, --dump-header FILE  将头信息写入指定的文件
    --egd-file FILE  为随机数据设置EGD socket路径(SSL)
    --engine ENGINGE  加密引擎 (SSL). "--engine list" 指定列表
-f, --fail          连接失败时不显示HTTP错误信息 (H)
-F, --form CONTENT  模拟 HTTP 表单数据提交（multipart POST） (H)
    --form-string STRING  模拟 HTTP 表单数据提交 (H)
    --ftp-account DATA  帐户数据提交 (F)
    --ftp-alternative-to-user COMMAND  指定替换 "USER [name]" 的字符串 (F)
    --ftp-create-dirs  如果不存在则创建远程目录 (F)
    --ftp-method [MULTICWD/NOCWD/SINGLECWD] 控制 CWD (F)
    --ftp-pasv      使用 PASV/EPSV 替换 PORT (F)
-P, --ftp-port ADR  使用指定 PORT 及地址替换 PASV (F)
    --ftp-skip-pasv-ip 跳过 PASV 的IP地址 (F)
    --ftp-pret      在 PASV 之前发送 PRET (drftpd) (F)
    --ftp-ssl-ccc   在认证之后发送 CCC (F)
    --ftp-ssl-ccc-mode ACTIVE/PASSIVE  设置 CCC 模式 (F)
    --ftp-ssl-control ftp 登录时需要 SSL/TLS (F)
-G, --get           使用 HTTP GET 方法发送 -d 数据  (H)
-g, --globoff       禁用的 URL 队列 及范围使用 {} 和 []
-H, --header LINE   要发送到服务端的自定义请求头 (H)
-I, --head          仅显示响应文档头
-h, --help          显示帮助
-0, --http1.0       使用 HTTP 1.0 (H)
    --ignore-content-length  忽略 HTTP Content-Length 头
-i, --include       在输出中包含协议头 (H/F)
-k, --insecure      允许连接到 SSL 站点，而不使用证书 (H)
    --interface INTERFACE  指定网络接口／地址
-4, --ipv4          将域名解析为 IPv4 地址
-6, --ipv6          将域名解析为 IPv6 地址
-j, --junk-session-cookies 读取文件中但忽略会话cookie (H)
    --keepalive-time SECONDS  keepalive 包间隔
    --key KEY       私钥文件名 (SSL/SSH)
    --key-type TYPE 私钥文件类型 (DER/PEM/ENG) (SSL)
    --krb LEVEL     启用指定安全级别的 Kerberos (F)
    --libcurl FILE  命令的libcurl等价代码
    --limit-rate RATE  限制传输速度
-l, --list-only    只列出FTP目录的名称 (F)
    --local-port RANGE  强制使用的本地端口号
-L, --location      跟踪重定向 (H)
    --location-trusted 类似 --location 并发送验证信息到其它主机 (H)
-M, --manual        显示全手动
    --mail-from FROM  从这个地址发送邮件
    --mail-rcpt TO  发送邮件到这个接收人(s)
    --mail-auth AUTH  原始电子邮件的起始地址
    --max-filesize BYTES  下载的最大文件大小 (H/F)
    --max-redirs NUM  最大重定向数 (H)
-m, --max-time SECONDS  允许的最多传输时间
    --metalink      处理指定的URL上的XML文件
    --negotiate     使用 HTTP Negotiate 认证 (H)
-n, --netrc         必须从 .netrc 文件读取用户名和密码
    --netrc-optional 使用 .netrc 或 URL; 将重写 -n 参数
    --netrc-file FILE  设置要使用的 netrc 文件名
-N, --no-buffer     禁用输出流的缓存
    --no-keepalive  禁用 connection 的 keepalive
    --no-sessionid  禁止重复使用 SSL session-ID (SSL)
    --noproxy       不使用代理的主机列表
    --ntlm          使用 HTTP NTLM 认证 (H)
-o, --output FILE   将输出写入文件，而非 stdout
    --pass PASS     传递给私钥的短语 (SSL/SSH)
    --post301       在 301 重定向后不要切换为 GET 请求 (H)
    --post302       在 302 重定向后不要切换为 GET 请求 (H)
    --post303       在 303 重定向后不要切换为 GET 请求 (H)
-#, --progress-bar  以进度条显示传输进度
    --proto PROTOCOLS  启用/禁用 指定的协议
    --proto-redir PROTOCOLS  在重定向上 启用/禁用 指定的协议
-x, --proxy [PROTOCOL://]HOST[:PORT] 在指定的端口上使用代理
    --proxy-anyauth 在代理上使用 "any" 认证方法 (H)
    --proxy-basic   在代理上使用 Basic 认证  (H)
    --proxy-digest  在代理上使用 Digest 认证 (H)
    --proxy-negotiate 在代理上使用 Negotiate 认证 (H)
    --proxy-ntlm    在代理上使用 NTLM 认证 (H)
-U, --proxy-user USER[:PASSWORD]  代理用户名及密码
     --proxy1.0 HOST[:PORT]  在指定的端口上使用 HTTP/1.0 代理
-p, --proxytunnel   使用HTTP代理 (用于 CONNECT)
    --pubkey KEY    公钥文件名 (SSH)
-Q, --quote CMD     在传输开始前向服务器发送命令 (F/SFTP)
    --random-file FILE  读取随机数据的文件 (SSL)
-r, --range RANGE   仅检索范围内的字节
    --raw           使用原始HTTP传输，而不使用编码 (H)
-e, --referer       Referer URL (H)
-J, --remote-header-name 从远程文件读取头信息 (H)
-O, --remote-name   将输出写入远程文件
    --remote-name-all 使用所有URL的远程文件名
-R, --remote-time   将远程文件的时间设置在本地输出上
-X, --request COMMAND  使用指定的请求命令
    --resolve HOST:PORT:ADDRESS  将 HOST:PORT 强制解析到 ADDRESS
    --retry NUM   出现问题时的重试次数
    --retry-delay SECONDS 重试时的延时时长
    --retry-max-time SECONDS  仅在指定时间段内重试
-S, --show-error    显示错误. 在选项 -s 中，当 curl 出现错误时将显示
-s, --silent        Silent模式。不输出任务内容
    --socks4 HOST[:PORT]  在指定的 host + port 上使用 SOCKS4 代理
    --socks4a HOST[:PORT]  在指定的 host + port 上使用 SOCKSa 代理
    --socks5 HOST[:PORT]  在指定的 host + port 上使用 SOCKS5 代理
    --socks5-hostname HOST[:PORT] SOCKS5 代理，指定用户名、密码
    --socks5-gssapi-service NAME  为gssapi使用SOCKS5代理服务名称
    --socks5-gssapi-nec  与NEC Socks5服务器兼容
-Y, --speed-limit RATE  在指定限速时间之后停止传输
-y, --speed-time SECONDS  指定时间之后触发限速. 默认 30
    --ssl           尝试 SSL/TLS (FTP, IMAP, POP3, SMTP)
    --ssl-reqd      需要 SSL/TLS (FTP, IMAP, POP3, SMTP)
-2, --sslv2         使用 SSLv2 (SSL)
-3, --sslv3         使用 SSLv3 (SSL)
    --ssl-allow-beast 允许的安全漏洞，提高互操作性(SSL)
    --stderr FILE   重定向 stderr 的文件位置. - means stdout
    --tcp-nodelay   使用 TCP_NODELAY 选项
-t, --telnet-option OPT=VAL  设置 telnet 选项
     --tftp-blksize VALUE  设备 TFTP BLKSIZE 选项 (必须 >512)
-z, --time-cond TIME  基于时间条件的传输
-1, --tlsv1         使用 => TLSv1 (SSL)
    --tlsv1.0       使用 TLSv1.0 (SSL)
    --tlsv1.1       使用 TLSv1.1 (SSL)
    --tlsv1.2       使用 TLSv1.2 (SSL)
    --trace FILE    将 debug 信息写入指定的文件
    --trace-ascii FILE  类似 --trace 但使用16进度输出
    --trace-time    向 trace/verbose 输出添加时间戳
    --tr-encoding   请求压缩传输编码 (H)
-T, --upload-file FILE  将文件传输（上传）到指定位置
    --url URL       指定所使用的 URL
-B, --use-ascii     使用 ASCII/text 传输
-u, --user USER[:PASSWORD]  指定服务器认证用户名、密码
    --tlsuser USER  TLS 用户名
    --tlspassword STRING TLS 密码
    --tlsauthtype STRING  TLS 认证类型 (默认 SRP)
    --unix-socket FILE    通过这个 UNIX socket 域连接
-A, --user-agent STRING  要发送到服务器的 User-Agent (H)
-v, --verbose       显示详细操作信息
-V, --version       显示版本号并退出
-w, --write-out FORMAT  完成后输出什么
    --xattr        将元数据存储在扩展文件属性中
-q                 .curlrc 如果作为第一个参数无效
```

## About

* **作者**：March
* **邮箱**：fengqi.mao.march@gmail.com
* **头条**：https://toutiao.io/u/425956/subjects
* **简书**：https://www.jianshu.com/u/02f2491c607d
* **掘金**：https://juejin.im/user/5b484473e51d45199940e2ae
* **CSDN**：http://blog.csdn.net/u011810138
* **SegmentFault**：https://segmentfault.com/u/maoqiqi
* **StackOverFlow**：https://stackoverflow.com/users/8223522

## License

```
   Copyright 2019 maoqiqi

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.
```